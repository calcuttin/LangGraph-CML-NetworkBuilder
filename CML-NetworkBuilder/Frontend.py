import streamlit as st
import pandas as pd
from dotenv import load_dotenv
load_dotenv()  # Ensure .env is loaded immediately at startup
import json
from datetime import datetime
import os
from langgraph.graph import StateGraph, END
from typing import TypedDict
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.tools import tool
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
import time

load_dotenv()


# Initialize chat history if not already in session state
if 'chat_history' not in st.session_state:
    st.session_state['chat_history'] = []

if 'lab_name' not in st.session_state:
    st.session_state['lab_name'] = "AutoGeneratedLab"  # Set default lab name

def show_flowchart_diagram():
    with st.expander("📈 Show MCP ➔ CML Deployment Flowchart"):
        flowchart_html = """
        <html>
        <head>
        <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
        </head>
        <body>
        <div id="flowchart" style="height: 500px;"></div>
        <script type="text/javascript">
        var nodes = new vis.DataSet([
            { id: 1, label: "MCP Model Ready" },
            { id: 2, label: "Assign Templates & Positions" },
            { id: 3, label: "Connect to CML Server" },
            { id: 4, label: "Create New Lab ID" },
            { id: 5, label: "Add Nodes (Routers/Switches/PCs)" },
            { id: 6, label: "Add Links (WAN/LAN)" },
            { id: 7, label: "Customize IPs & VLANs" },
            { id: 8, label: "Deploy to CML" },
            { id: 9, label: "Lab Running!" }
        ]);

        var edges = new vis.DataSet([
            { from: 1, to: 2 },
            { from: 2, to: 3 },
            { from: 3, to: 4 },
            { from: 4, to: 5 },
            { from: 5, to: 6 },
            { from: 6, to: 7 },
            { from: 7, to: 8 },
            { from: 8, to: 9 }
        ]);

        var container = document.getElementById('flowchart');
        var data = { nodes: nodes, edges: edges };
        var options = {
          layout: { hierarchical: { direction: "UD", sortMethod: "hubsize" }},
          physics: { hierarchicalRepulsion: { nodeDistance: 150 } }
        };
        var network = new vis.Network(container, data, options);
        </script>
        </body>
        </html>
        """
        st.components.v1.html(flowchart_html, height=600, scrolling=True)


# ----------------------
# Visual Network Topology Drawing
# ----------------------
from pyvis.network import Network
import streamlit.components.v1 as components

@st.cache_data
def load_network_topology_html(filename: str):
    with open(filename, "r") as f:
        return f.read()

def draw_network_topology(mcp_model: dict):
    print(f"Drawing network topology for: {mcp_model}")  # Debugging line to check data
    net = Network(height="700px", width="100%", bgcolor="#ffffff", font_color="black", notebook=False)

    devices = mcp_model.get("network_design", {}).get("devices", [])
    links = mcp_model.get("network_design", {}).get("links", [])

    # Map device types to colors and shapes
    type_color_map = {
        "router": "lightblue",
        "switch": "lightgreen",
        "firewall": "salmon",
        "server": "lightgray"
    }

    shape_map = {
        "router": "ellipse",
        "switch": "box",
        "firewall": "diamond",
        "server": "ellipse"
    }

    # Add nodes with interactive tooltips showing device type
    for device in devices:
        name = device.get("name")
        dev_type = device.get("type", "router")
        color = type_color_map.get(dev_type.lower(), "gray")
        shape = shape_map.get(dev_type.lower(), "ellipse")
        # Add a dynamic title for interactivity (hover/click info panel)
        net.add_node(
            name,
            label=name,
            title=f"Device: {name} ({dev_type.title()})",
            color=color,
            shape=shape,
            size=30
        )

    # Add links with directional arrows
    for link in links:
        endpoints = link.get("endpoints", [])
        link_type = link.get("link_type", "ethernet")
        if len(endpoints) == 2:
            net.add_edge(endpoints[0], endpoints[1], label=link_type, arrows="to", font={"size": 12})

    # Physics/layout settings for hierarchical (left-to-right) flowchart style
    net.set_options("""
    var options = {
      "layout": {
        "hierarchical": {
          "enabled": true,
          "direction": "LR",
          "sortMethod": "hubsize"
        }
      },
      "physics": {
        "hierarchicalRepulsion": {
          "nodeDistance": 150
        },
        "minVelocity": 0.75
      }
    }
    """)

    os.makedirs("saved_models", exist_ok=True)
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"saved_models/network_topology_mcp_builder_{timestamp}.html"
    net.save_graph(filename)
    html_content = load_network_topology_html(filename)
    components.html(html_content, height=750, scrolling=True)

class NetworkRequestState(TypedDict):
    input: str
    output: dict | None

# ----------------------
# Tools: Basic "network intent" parser
# ----------------------

@tool
def parse_network_request(text: str) -> dict:
    """
    Parses a natural language network request and suggests a basic topology.
    """
    lowered = text.lower()

    if "2 routers" in lowered:
        return {"devices": ["Router1", "Router2"], "links": [("Router1", "Router2")], "protocol": "static"}
    
    elif "ospf" in lowered and "3 routers" in lowered:
        return {"devices": ["Router1", "Router2", "Router3"], "links": [("Router1", "Router2"), ("Router2", "Router3")], "protocol": "ospf"}
    
    elif "3 routers" in lowered and "serial" in lowered:
        return {
            "devices": ["RouterA", "RouterB", "RouterC"],
            "links": [
                ("RouterA", "RouterB"),
                ("RouterB", "RouterC"),
                ("RouterC", "RouterA")
            ],
            "protocol": "static",
            "link_type": "serial"
        }
    
    else:
        return {"error": "Request too complex or unsupported (MVP only supports 2-3 router networks with static or OSPF protocols)."}

# ----------------------
# LangGraph Setup
# ----------------------

tools = [parse_network_request]
llm = ChatOpenAI(model="gpt-4o", temperature=0, api_key=os.getenv("OPENAI_API_KEY"))

prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful network design assistant."),
    ("human", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad")
])

agent = create_tool_calling_agent(llm, tools, prompt=prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

builder = StateGraph(NetworkRequestState)
builder.add_node("agent", agent_executor)
builder.set_entry_point("agent")
builder.add_edge("agent", END)
graph = builder.compile()

# ----------------------
# Streamlit UI with Chat History
# ----------------------

st.title("🧠💻 LangGraph Network Builder")

show_flowchart_diagram()

# ----------------------
# Prebuilt Topology Templates
# ----------------------
st.sidebar.subheader("📚 Templates")

templates = {
    "Hub and Spoke (3 Routers) (STATIC)": {
        "network_design": {
            "devices": [
                {
                    "name": "HubRouter",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname HubRouter\ninterface GigabitEthernet0/0\n ip address 10.1.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.1.2.1 255.255.255.252\n no shutdown"
                },
                {
                    "name": "Spoke1",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Spoke1\ninterface GigabitEthernet0/0\n ip address 10.1.1.2 255.255.255.252\n no shutdown"
                },
                {
                    "name": "Spoke2",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Spoke2\ninterface GigabitEthernet0/0\n ip address 10.1.2.2 255.255.255.252\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["HubRouter", "Spoke1"], "link_type": "serial"},
                {"endpoints": ["HubRouter", "Spoke2"], "link_type": "serial"}
            ]
        }
    },
    "Full Mesh (3 Routers) (STATIC)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterA",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterA\ninterface GigabitEthernet0/0\n ip address 10.0.0.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.5 255.255.255.252\n no shutdown"
                },
                {
                    "name": "RouterB",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterB\ninterface GigabitEthernet0/0\n ip address 10.0.0.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.9 255.255.255.252\n no shutdown"
                },
                {
                    "name": "RouterC",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterC\ninterface GigabitEthernet0/0\n ip address 10.0.0.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.10 255.255.255.252\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["RouterA", "RouterB"], "link_type": "serial"},
                {"endpoints": ["RouterB", "RouterC"], "link_type": "serial"},
                {"endpoints": ["RouterC", "RouterA"], "link_type": "serial"}
            ]
        }
    },
    "Campus LAN (VLANs & Router-on-a-Stick)": {
        "network_design": {
            "devices": [
                {
                    "name": "CoreRouter",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname CoreRouter\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.10\n encapsulation dot1Q 10\n ip address 192.168.10.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.20\n encapsulation dot1Q 20\n ip address 192.168.20.1 255.255.255.0\n no shutdown"
                },
                {
                    "name": "CoreSwitch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname CoreSwitch\nvlan 10\nvlan 20\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 10\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 20\n no shutdown"
                },
                {
                    "name": "AccessSwitch1",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname AccessSwitch1\ninterface GigabitEthernet0/1\n switchport access vlan 10\n no shutdown"
                },
                {
                    "name": "AccessSwitch2",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname AccessSwitch2\ninterface GigabitEthernet0/1\n switchport access vlan 20\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["CoreRouter", "CoreSwitch"], "link_type": "ethernet"},
                {"endpoints": ["CoreSwitch", "AccessSwitch1"], "link_type": "ethernet"},
                {"endpoints": ["CoreSwitch", "AccessSwitch2"], "link_type": "ethernet"}
            ]
        }
    },
    "Full Mesh OSPF Lab (3 Routers)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterA",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterA\ninterface GigabitEthernet0/0\n ip address 10.0.0.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.5 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                },
                {
                    "name": "RouterB",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterB\ninterface GigabitEthernet0/0\n ip address 10.0.0.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.9 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                },
                {
                    "name": "RouterC",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterC\ninterface GigabitEthernet0/0\n ip address 10.0.0.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.10 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                }
            ],
            "links": [
                {"endpoints": ["RouterA", "RouterB"], "link_type": "serial"},
                {"endpoints": ["RouterB", "RouterC"], "link_type": "serial"},
                {"endpoints": ["RouterC", "RouterA"], "link_type": "serial"}
            ]
        }
    },
    "Full Mesh EIGRP Lab (3 Routers)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterX",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterX\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.5 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                },
                {
                    "name": "RouterY",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterY\ninterface GigabitEthernet0/0\n ip address 192.168.1.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.9 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                },
                {
                    "name": "RouterZ",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterZ\ninterface GigabitEthernet0/0\n ip address 192.168.1.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.10 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                }
            ],
            "links": [
                {"endpoints": ["RouterX", "RouterY"], "link_type": "serial"},
                {"endpoints": ["RouterY", "RouterZ"], "link_type": "serial"},
                {"endpoints": ["RouterZ", "RouterX"], "link_type": "serial"}
            ]
        }
    },
    "Multi-Site WAN + LAN Mega-Lab (Multi-Area OSPF + VLANs + PCs)": {
        "network_design": {
            "devices": [
                {
                    "name": "Site1_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Site1_Router\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.10\n encapsulation dot1Q 10\n ip address 10.1.10.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.20\n encapsulation dot1Q 20\n ip address 10.1.20.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.2 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.1.0.0 0.0.255.255 area 1\n network 172.16.1.0 0.0.0.3 area 0\nip route 10.2.0.0 255.255.0.0 172.16.1.1"
                },
                {
                    "name": "Site2_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Site2_Router\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.30\n encapsulation dot1Q 30\n ip address 10.2.30.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.40\n encapsulation dot1Q 40\n ip address 10.2.40.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.6 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.2.0.0 0.0.255.255 area 2\n network 172.16.1.4 0.0.0.3 area 0\nip route 10.1.0.0 255.255.0.0 172.16.1.5"
                },
                {
                    "name": "WAN_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname WAN_Router\ninterface GigabitEthernet0/0\n ip address 172.16.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.5 255.255.255.252\n no shutdown\nrouter ospf 1\n network 172.16.1.0 0.0.0.3 area 0\n network 172.16.1.4 0.0.0.3 area 0\n network 10.1.0.0 0.0.255.255 area 1\n network 10.2.0.0 0.0.255.255 area 2"
                },
                {
                    "name": "Site1_Switch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname Site1_Switch\nvlan 10\nvlan 20\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 10\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 20\n no shutdown"
                },
                {
                    "name": "Site2_Switch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname Site2_Switch\nvlan 30\nvlan 40\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 30\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 40\n no shutdown"
                },
                {
                    "name": "Site1_PC",
                    "type": "ext-server",
                    "node_definition": "ext-server",
                    "config": "#cloud-config\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: false\n      addresses: [192.168.10.10/24]\n      gateway4: 192.168.10.1\n      nameservers:\n        addresses: [8.8.8.8]"
                },
                {
                    "name": "Site2_PC",
                    "type": "ext-server",
                    "node_definition": "ext-server",
                    "config": "#cloud-config\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: false\n      addresses: [192.168.30.10/24]\n      gateway4: 192.168.30.1\n      nameservers:\n        addresses: [8.8.8.8]"
                }
            ],
            "links": [
                {"endpoints": ["Site1_Router", "WAN_Router"], "link_type": "serial"},
                {"endpoints": ["Site2_Router", "WAN_Router"], "link_type": "serial"},
                {"endpoints": ["Site1_Router", "Site1_Switch"], "link_type": "ethernet"},
                {"endpoints": ["Site2_Router", "Site2_Switch"], "link_type": "ethernet"},
                {"endpoints": ["Site1_Switch", "Site1_PC"], "link_type": "ethernet"},
                {"endpoints": ["Site2_Switch", "Site2_PC"], "link_type": "ethernet"}
            ]
        }
    }
}


template_choice = st.sidebar.selectbox("Select a Template", ["Select..."] + list(templates.keys()))

if template_choice != "Select...":
    selected_template = templates[template_choice]

    # VLAN ID customization for Campus LAN (VLANs & Router-on-a-Stick)
    if template_choice == "Campus LAN (VLANs & Router-on-a-Stick)":
        vlan10 = st.sidebar.text_input("Enter VLAN ID for User VLAN", value="10")
        vlan20 = st.sidebar.text_input("Enter VLAN ID for Voice VLAN", value="20")

        if vlan10 and vlan20:
            # Deep copy and replace VLAN IDs dynamically
            selected_template = json.loads(
                json.dumps(selected_template)
                .replace("vlan 10", f"vlan {vlan10}")
                .replace("vlan 20", f"vlan {vlan20}")
                .replace(".10", f".{vlan10}")
                .replace(".20", f".{vlan20}")
            )

    st.session_state['last_mcp_model'] = selected_template

    # --- Begin: Editable device config table with preview and reset ---
    st.subheader("🛠️ Customize Device Configurations Before Deployment")

    original_devices = pd.DataFrame(selected_template["network_design"]["devices"])
    editable_devices = st.data_editor(
        original_devices.copy(),
        num_rows="dynamic",
        use_container_width=True
    )

    st.markdown("### 🧩 Changes Preview")
    if editable_devices.shape == original_devices.shape and all(editable_devices.columns == original_devices.columns):
        differences = editable_devices.compare(original_devices)
        if not differences.empty:
            st.dataframe(differences, use_container_width=True)
        else:
            st.success("✅ No changes detected yet.")
    else:
        st.warning("⚡ You added or removed devices — changes will apply, but full comparison preview is disabled.")

    # Overwrite the device configs with edited data
    if st.button("💾 Apply Edits to Devices"):
        try:
            selected_template["network_design"]["devices"] = editable_devices.to_dict(orient="records")
            st.success("✅ Updated device configurations applied.")
        except Exception as e:
            st.error(f"❌ Failed to update device configurations: {e}")

    # Add a Reset Edits Button
    if st.button("🔄 Reset Device Edits"):
        st.rerun()
    # --- End: Editable device config table with preview and reset ---

    st.success(f"✅ Template `{template_choice}` loaded into session. You can now deploy it!")
    with st.spinner("Rendering network diagram..."):
        draw_network_topology(selected_template)

# ----------------------
# Save Current Topology as Template (Sidebar)
# ----------------------
st.sidebar.subheader("📝 Save Current Topology as Template")

if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model']:
    template_name = st.sidebar.text_input("Enter a name for the new template:")
    if st.sidebar.button("💾 Save as Template"):
        if template_name.strip() == "":
            st.sidebar.error("❌ Please enter a valid name.")
        else:
            os.makedirs("custom_templates", exist_ok=True)
            save_path = f"custom_templates/{template_name}.json"
            try:
                with open(save_path, "w") as f:
                    json.dump(st.session_state['last_mcp_model'], f, indent=4)
                st.sidebar.success(f"✅ Template `{template_name}` saved successfully!")
            except Exception as e:
                st.sidebar.error(f"❌ Failed to save template: {e}")
else:
    st.sidebar.info("ℹ️ No MCP model available to save as template.")

# ----------------------
# Save MCP Model with Nickname
# ----------------------
st.subheader("💾 Save Current MCP Model with Custom Name")

if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model']:
    custom_name = st.text_input("Enter a custom name for this topology (no spaces, keep it simple):")
    if st.button("📥 Save Topology"):
        if custom_name.strip() == "":
            st.error("❌ Please enter a valid name.")
        else:
            os.makedirs("saved_models", exist_ok=True)
            save_path = f"saved_models/{custom_name}.json"
            try:
                with open(save_path, "w") as f:
                    json.dump(st.session_state['last_mcp_model'], f, indent=4)
                st.success(f"✅ Topology saved as `{save_path}`")
            except Exception as e:
                st.error(f"❌ Failed to save topology: {e}")
else:
    st.info("ℹ️ No MCP model to save yet.")

# ----------------------
# User Input: Lab Name
# ----------------------
st.session_state['lab_name'] = st.text_input("🖥️ Enter Lab ID", st.session_state['lab_name'])

# Display previous chat history
for message in st.session_state['chat_history']:
    with st.chat_message(message["role"]):
        st.markdown(message["text"])

# Get user input
user_input = st.chat_input("Describe your desired network topology...")

if user_input:
    with st.chat_message("user"):
        st.markdown(user_input)

    # Add user input to history
    st.session_state['chat_history'].append({"role": "user", "text": user_input})
    if len(st.session_state['chat_history']) > 10:
        st.session_state['chat_history'] = st.session_state['chat_history'][-10:]

    with st.spinner("Thinking..."):
        try:
            result = graph.invoke({"input": user_input})

            # Auto-retry if the output is not a structured dict
            if result and isinstance(result.get("output"), str):
                st.warning("⚠️ Agent returned text instead of a structured model. Attempting enhanced fallback parsing...")
                user_fallback_prompt = f"""
                You are a network topology extraction agent.

                Extract ONLY the list of devices and links in JSON format, structured exactly like this:

                {{
                  "devices": [
                    {{"name": "RouterA", "type": "router"}},
                    {{"name": "RouterB", "type": "router"}},
                    {{"name": "Switch1", "type": "switch"}}
                  ],
                  "links": [
                    {{"endpoints": ["RouterA", "RouterB"], "link_type": "serial"}},
                    {{"endpoints": ["RouterB", "Switch1"], "link_type": "ethernet"}}
                  ]
                }}

                Now extract based on this input:
                \"\"\"
                {result['output']}
                \"\"\"

                ONLY respond with a valid JSON object matching this format. No explanations, no commentary.
                """
                result = graph.invoke({"input": user_fallback_prompt})

                import re

                # Clean triple backtick formatting if present
                if result and isinstance(result.get("output"), str):
                    cleaned_output = result["output"].strip()
                    if cleaned_output.startswith("```"):
                        cleaned_output = re.sub(r"^```.*?\n", "", cleaned_output, flags=re.DOTALL)
                        cleaned_output = re.sub(r"```$", "", cleaned_output.strip())
                    
                    try:
                        result["output"] = json.loads(cleaned_output)
                        st.success("✅ Cleaned and parsed fallback JSON successfully.")
                    except Exception as e:
                        st.error(f"❌ Failed to parse cleaned fallback JSON: {e}")
                        result["output"] = None

            # Ensure MCP model is properly structured with "network_design"
            if result and result.get("output") and "network_design" not in result["output"]:
                result["output"] = {
                    "network_design": result["output"]
                }

            # Enhance the MCP model before saving or deploying
            valid_node_definitions = {"iosv", "iosvl2", "csr1000v", "nxosv", "ubuntu", "server", "ext-server"}

            devices = result["output"].get("network_design", {}).get("devices", [])
            links = result["output"].get("network_design", {}).get("links", [])

            if devices:
                x, y = 100, 100
                x_offset, y_offset = 200, 200
                max_per_row = 3
                count = 0

                role_to_template = {
                    "router": "iosv",
                    "switch": "iosvl2",
                    "firewall": "asav",
                    "server": "ubuntu"
                }

                # --- Begin IP addressing enrichment ---
                base_ip_octets = [10, 0, 0, 0]  # Start at 10.0.0.0
                subnet_step = 4  # /30 blocks
                link_ip_map = {}
                device_interfaces = {device["name"]: [] for device in devices}

                def increment_ip(ip_octets, increment):
                    ip_int = (ip_octets[0] << 24) + (ip_octets[1] << 16) + (ip_octets[2] << 8) + ip_octets[3]
                    ip_int += increment
                    return [(ip_int >> 24) & 0xFF, (ip_int >> 16) & 0xFF, (ip_int >> 8) & 0xFF, ip_int & 0xFF]

                for link in links:
                    endpoints = link.get("endpoints", [])
                    if len(endpoints) == 2:
                        subnet_base = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]}"
                        device_a_ip = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]+1}"
                        device_b_ip = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]+2}"
                        link_ip_map[(endpoints[0], endpoints[1])] = (device_a_ip, device_b_ip)

                        # Increment to next /30 block
                        base_ip_octets = increment_ip(base_ip_octets, subnet_step)

                # --- End IP addressing enrichment ---

                for device in devices:
                    device_type = device.get("type", "router").lower()

                    if "node_definition" not in device or device["node_definition"] not in valid_node_definitions:
                        device["node_definition"] = role_to_template.get(device_type, "iosv")

                    if "x" not in device or "y" not in device:
                        device["x"] = x
                        device["y"] = y

                        count += 1
                        if count % max_per_row == 0:
                            x = 100
                            y += y_offset
                        else:
                            x += x_offset

                # Build per-device configs with interface IPs
                for device in devices:
                    config_lines = [f"hostname {device['name']}"]
                    iface_count = 0
                    for link, ips in link_ip_map.items():
                        if device["name"] == link[0]:
                            config_lines.append(f"interface GigabitEthernet0/{iface_count}")
                            config_lines.append(f" ip address {ips[0]} 255.255.255.252")
                            config_lines.append(f" no shutdown")
                            iface_count += 1
                        elif device["name"] == link[1]:
                            config_lines.append(f"interface GigabitEthernet0/{iface_count}")
                            config_lines.append(f" ip address {ips[1]} 255.255.255.252")
                            config_lines.append(f" no shutdown")
                            iface_count += 1
                    device["config"] = "\n".join(config_lines)

            # Save MCP model to session state for later use
            if result and result.get("output"):
                st.session_state['last_mcp_model'] = result["output"]

        except Exception as e:
            st.error(f"❌ Graph execution failed: {e}")
            result = None

    if result:
        with st.chat_message("assistant"):
            st.subheader("Agent Output:")
            # Debug console expander for raw output
            with st.expander("🛠️ Debug Console (Raw Output)"):
                debug_preview = json.dumps(result, indent=2)
                if len(debug_preview) > 2000:
                    debug_preview = debug_preview[:2000] + "\n...\n⚠️ Output truncated for performance."
                st.code(debug_preview, language="json")
            st.json(result)

        # Add assistant message to history
        st.session_state['chat_history'].append({"role": "assistant", "text": json.dumps(result)})
        if len(st.session_state['chat_history']) > 10:
            st.session_state['chat_history'] = st.session_state['chat_history'][-10:]

        # ----------------------
        # Save MCP Model to JSON file with smarter filename
        # ----------------------
        os.makedirs("saved_models", exist_ok=True)  # Create folder if missing
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        # Attempt smarter filename from device names
        try:
            first_device = result["output"]["network_design"]["devices"][0]["name"]
            clean_name = first_device.replace(" ", "_").lower()
        except Exception:
            clean_name = "mcp_model"
        save_path = f"saved_models/{clean_name}_{timestamp}.json"
        with open(save_path, "w") as f:
            json.dump(result["output"], f, indent=4)
        
        st.success(f"✅ MCP Model saved to `{save_path}`!")
        st.subheader("🌐 Visualized Network Topology:")
        with st.spinner("Rendering network diagram..."):
            draw_network_topology(result["output"])

elif user_input:
    st.error("❌ Unexpected error. Please try again.")

# ----------------------
# Advanced Controls: Export, Reload, Start/Stop
# ----------------------
st.subheader("⚙️ Advanced Controls")

col1, col2, col3 = st.columns(3)

with col1:
    if st.button("📥 Export Network Diagram"):  
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        export_filename = f"saved_models/network_topology_mcp_builder_{timestamp}.html"
        st.success(f"Diagram exported as `{export_filename}`")

with col2:
    saved_files = [f for f in os.listdir("saved_models") if f.endswith(".json")]
    saved_names = [os.path.splitext(f)[0] for f in saved_files]  # Remove .json for display
    selected_file = st.selectbox("📂 Reload Saved Topology", ["Select a file..."] + saved_names)

    if selected_file != "Select a file...":
        load_path = f"saved_models/{selected_file}.json"
        with open(load_path, "r") as f:
            loaded_mcp_model = json.load(f)
        st.info(f"✅ Loaded `{selected_file}`")
        with st.spinner("Rendering network diagram..."):
            draw_network_topology(loaded_mcp_model)

        # Allow editing the loaded topology
        st.subheader("📝 Edit Loaded Topology")

        editable_json = st.text_area("Modify the JSON structure below:", json.dumps(loaded_mcp_model, indent=2), height=400)

        # --- Enhanced: Three buttons for Save, Deploy, Save+Deploy ---
        edited_model = None
        col_edit1, col_edit2, col_edit3 = st.columns(3)

        with col_edit1:
            if st.button("💾 Save Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    save_edit_path = f"saved_models/edited_{selected_file}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.json"
                    with open(save_edit_path, "w") as f:
                        json.dump(edited_model, f, indent=4)
                    st.success(f"✅ Edited topology saved as `{save_edit_path}`")
                except Exception as e:
                    st.error(f"❌ Failed to save edited topology: {e}")

        with col_edit2:
            if st.button("🚀 Deploy Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    from CMLConnector import CMLManager
                    cml_manager = CMLManager()
                    lab_name = f"EditedLab_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    lab = cml_manager.create_lab_from_mcp(edited_model, lab_name)
                    st.success(f"✅ Edited topology deployed! Lab ID: {lab.id}")
                except Exception as e:
                    st.error(f"❌ Failed to deploy edited topology: {e}")

        with col_edit3:
            if st.button("💾+🚀 Save and Deploy Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    save_edit_path = f"saved_models/edited_{selected_file}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.json"
                    with open(save_edit_path, "w") as f:
                        json.dump(edited_model, f, indent=4)
                    from CMLConnector import CMLManager
                    cml_manager = CMLManager()
                    lab_name = f"EditedLab_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    lab = cml_manager.create_lab_from_mcp(edited_model, lab_name)
                    st.success(f"✅ Edited topology saved and deployed! Lab ID: {lab.id}")
                except Exception as e:
                    st.error(f"❌ Failed to save and deploy edited topology: {e}")

with col3:
    st.markdown("🚀 **Lab Controls**")

    if st.button("🚀 Deploy New Lab from Model"):
        try:
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()  # Lazy instantiate

            if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model'] is not None:
                if not st.session_state['lab_name']:
                    st.error("❌ Please enter a Lab ID first!")
                    st.stop()

                st.text("🛠 Creating lab...")
                lab = cml_manager.create_lab_from_mcp(st.session_state['last_mcp_model'], st.session_state['lab_name'])
                st.success(f"✅ New Lab Created! Lab ID: {lab.id}")

                st.session_state['last_created_lab_id'] = lab.id
            else:
                st.error("❌ No MCP model available to deploy. Please describe a network first.")
        except Exception as e:
            st.error(f"❌ Failed to deploy new lab: {e}")

    # Start and Stop buttons (appear only AFTER deploy)
    if 'last_created_lab_id' in st.session_state:
        lab_id = st.session_state['last_created_lab_id']
        if st.button("▶️ Start Lab"):
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()
            st.text("Starting lab...")
            cml_manager.start_lab(lab_id)
            st.success("✅ Lab start requested!")

        if st.button("⏹ Stop Lab"):
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()
            st.text("Stopping lab...")
            cml_manager.stop_lab(lab_id)
            st.success("✅ Lab stop requested!")

# ----------------------
# Test CML Connection Button
# ----------------------
st.subheader("🧪 Test CML Server Connection")

# Visual connection status indicator
connection_status = st.empty()

if st.button("🔍 Test CML Connection"):
    try:
        from CMLConnector import CMLManager
        cml_manager = CMLManager()
        version = cml_manager.client.system_info().get("version", "Unknown")
        connection_status.success(f"🟢 Connected to CML server (Version: {version})")
    except Exception as e:
        error_message = str(e)
        if "Errno 60" in error_message or "timed out" in error_message.lower():
            connection_status.error("🔴 Could not connect to CML server: Server unreachable (timed out after 5 seconds).")
        else:
            connection_status.error(f"🔴 Could not connect to CML server: {error_message}")