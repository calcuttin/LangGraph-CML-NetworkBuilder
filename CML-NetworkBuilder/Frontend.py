import streamlit as st
import pandas as pd
from dotenv import load_dotenv
load_dotenv()  # Ensure .env is loaded immediately at startup
import json
from datetime import datetime
import os
from langgraph.graph import StateGraph, END
from typing import TypedDict
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.tools import tool
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
import time

load_dotenv()


# Initialize chat history if not already in session state
if 'chat_history' not in st.session_state:
    st.session_state['chat_history'] = []

if 'lab_name' not in st.session_state:
    st.session_state['lab_name'] = "AutoGeneratedLab"  # Set default lab name

def show_flowchart_diagram():
    with st.expander("üìà MCP ‚ûî CML Deployment Flowchart (Static)"):
        flowchart_html = """
<style>
.flowchart-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: Arial, sans-serif;
}
.flowchart-step {
    border: 2px solid #4a90e2;
    border-radius: 8px;
    padding: 12px 24px;
    margin: 8px 0;
    width: 320px;
    text-align: center;
    font-size: 16px;
    position: relative;
}
.phase-prep { background-color: #e3f2fd; }
.phase-config { background-color: #e8f5e9; }
.phase-deploy { background-color: #fff3e0; }
.phase-run { background-color: #ede7f6; }
.flowchart-step::after {
    content: "‚Üì";
    position: absolute;
    left: 50%;
    bottom: -20px;
    transform: translateX(-50%);
    font-size: 18px;
}
.flowchart-step:last-child::after {
    content: "";
}
</style>
<div class="flowchart-container" id="flowchart">
    <div class="flowchart-step phase-prep">MCP Model Ready</div>
    <div class="flowchart-step phase-prep">Assign Templates & Positions</div>
    <div class="flowchart-step phase-config">Connect to CML Server</div>
    <div class="flowchart-step phase-config">Create New Lab ID</div>
    <div class="flowchart-step phase-config">Add Nodes (Routers/Switches/PCs)</div>
    <div class="flowchart-step phase-config">Add Links (WAN/LAN)</div>
    <div class="flowchart-step phase-config">Customize IPs & VLANs</div>
    <div class="flowchart-step phase-deploy">Deploy to CML</div>
    <div class="flowchart-step phase-run">Lab Running!</div>
</div>
"""
        st.components.v1.html(flowchart_html, height=600, scrolling=True)
    # Expose flowchart_html for export outside the function
    return flowchart_html


# ----------------------
# Visual Network Topology Drawing
# ----------------------
from pyvis.network import Network
import streamlit.components.v1 as components

@st.cache_data
def load_network_topology_html(filename: str):
    with open(filename, "r") as f:
        return f.read()

def draw_network_topology(mcp_model: dict):
    print(f"Drawing network topology for: {mcp_model}")  # Debugging line to check data
    net = Network(height="700px", width="100%", bgcolor="#ffffff", font_color="black", notebook=False)

    devices = mcp_model.get("network_design", {}).get("devices", [])
    links = mcp_model.get("network_design", {}).get("links", [])

    # Map device types to colors and shapes
    type_color_map = {
        "router": "lightblue",
        "switch": "lightgreen",
        "firewall": "salmon",
        "server": "lightgray"
    }

    shape_map = {
        "router": "ellipse",
        "switch": "box",
        "firewall": "diamond",
        "server": "ellipse"
    }

    # Add nodes with interactive tooltips showing device type
    for device in devices:
        name = device.get("name")
        dev_type = device.get("type", "router")
        color = type_color_map.get(dev_type.lower(), "gray")
        shape = shape_map.get(dev_type.lower(), "ellipse")
        # Add a dynamic title for interactivity (hover/click info panel)
        net.add_node(
            name,
            label=name,
            title=f"Device: {name} ({dev_type.title()})",
            color=color,
            shape=shape,
            size=30
        )

    # Add links with directional arrows
    for link in links:
        endpoints = link.get("endpoints", [])
        link_type = link.get("link_type", "ethernet")
        if len(endpoints) == 2:
            net.add_edge(endpoints[0], endpoints[1], label=link_type, arrows="to", font={"size": 12})

    # Physics/layout settings for hierarchical (left-to-right) flowchart style
    net.set_options("""
    var options = {
      "layout": {
        "hierarchical": {
          "enabled": true,
          "direction": "LR",
          "sortMethod": "hubsize"
        }
      },
      "physics": {
        "hierarchicalRepulsion": {
          "nodeDistance": 150
        },
        "minVelocity": 0.75
      }
    }
    """)

    os.makedirs("saved_models", exist_ok=True)
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filename = f"saved_models/network_topology_mcp_builder_{timestamp}.html"
    net.save_graph(filename)
    html_content = load_network_topology_html(filename)
    components.html(html_content, height=750, scrolling=True)

class NetworkRequestState(TypedDict):
    input: str
    output: dict | None

# ----------------------
# Tools: Basic "network intent" parser
# ----------------------

@tool
def parse_network_request(text: str) -> dict:
    """
    Parses a natural language network request and suggests a basic topology.
    """
    lowered = text.lower()

    if "2 routers" in lowered:
        return {"devices": ["Router1", "Router2"], "links": [("Router1", "Router2")], "protocol": "static"}
    
    elif "ospf" in lowered and "3 routers" in lowered:
        return {"devices": ["Router1", "Router2", "Router3"], "links": [("Router1", "Router2"), ("Router2", "Router3")], "protocol": "ospf"}
    
    elif "3 routers" in lowered and "serial" in lowered:
        return {
            "devices": ["RouterA", "RouterB", "RouterC"],
            "links": [
                ("RouterA", "RouterB"),
                ("RouterB", "RouterC"),
                ("RouterC", "RouterA")
            ],
            "protocol": "static",
            "link_type": "serial"
        }
    
    else:
        return {"error": "Request too complex or unsupported (MVP only supports 2-3 router networks with static or OSPF protocols)."}

# ----------------------
# LangGraph Setup
# ----------------------

tools = [parse_network_request]
llm = ChatOpenAI(model="gpt-4o", temperature=0, api_key=os.getenv("OPENAI_API_KEY"))

prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful network design assistant."),
    ("human", "{input}"),
    MessagesPlaceholder(variable_name="agent_scratchpad")
])

agent = create_tool_calling_agent(llm, tools, prompt=prompt)
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)

builder = StateGraph(NetworkRequestState)
builder.add_node("agent", agent_executor)
builder.set_entry_point("agent")
builder.add_edge("agent", END)
graph = builder.compile()

# ----------------------
# Streamlit UI with Chat History
# ----------------------

st.title("üß†üíª LangGraph Network Builder")

# Show the flowchart and get the HTML for export
flowchart_html = show_flowchart_diagram()

# ---- Sidebar: Export Flowchart as PNG ----
st.sidebar.subheader("üñº Export Flowchart")
if st.sidebar.button("üì∏ Save Flowchart as PNG"):
    try:
        import imgkit
        flowchart_file = "saved_models/flowchart_export.html"
        output_png = "saved_models/flowchart_export.png"
        with open(flowchart_file, "w") as f:
            f.write(flowchart_html)
        imgkit.from_file(flowchart_file, output_png)
        st.sidebar.success(f"‚úÖ Flowchart exported as {output_png}")
    except Exception as e:
        st.sidebar.error(f"‚ùå Failed to export flowchart: {e}")

# ----------------------
# Prebuilt Topology Templates
# ----------------------
st.sidebar.subheader("üìö Templates")

templates = {
    "Hub and Spoke (3 Routers) (STATIC)": {
        "network_design": {
            "devices": [
                {
                    "name": "HubRouter",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname HubRouter\ninterface GigabitEthernet0/0\n ip address 10.1.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.1.2.1 255.255.255.252\n no shutdown"
                },
                {
                    "name": "Spoke1",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Spoke1\ninterface GigabitEthernet0/0\n ip address 10.1.1.2 255.255.255.252\n no shutdown"
                },
                {
                    "name": "Spoke2",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Spoke2\ninterface GigabitEthernet0/0\n ip address 10.1.2.2 255.255.255.252\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["HubRouter", "Spoke1"], "link_type": "serial"},
                {"endpoints": ["HubRouter", "Spoke2"], "link_type": "serial"}
            ]
        }
    },
    "Full Mesh (3 Routers) (STATIC)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterA",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterA\ninterface GigabitEthernet0/0\n ip address 10.0.0.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.5 255.255.255.252\n no shutdown"
                },
                {
                    "name": "RouterB",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterB\ninterface GigabitEthernet0/0\n ip address 10.0.0.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.9 255.255.255.252\n no shutdown"
                },
                {
                    "name": "RouterC",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterC\ninterface GigabitEthernet0/0\n ip address 10.0.0.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.10 255.255.255.252\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["RouterA", "RouterB"], "link_type": "serial"},
                {"endpoints": ["RouterB", "RouterC"], "link_type": "serial"},
                {"endpoints": ["RouterC", "RouterA"], "link_type": "serial"}
            ]
        }
    },
    "Campus LAN (VLANs & Router-on-a-Stick)": {
        "network_design": {
            "devices": [
                {
                    "name": "CoreRouter",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname CoreRouter\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.10\n encapsulation dot1Q 10\n ip address 192.168.10.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.20\n encapsulation dot1Q 20\n ip address 192.168.20.1 255.255.255.0\n no shutdown"
                },
                {
                    "name": "CoreSwitch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname CoreSwitch\nvlan 10\nvlan 20\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 10\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 20\n no shutdown"
                },
                {
                    "name": "AccessSwitch1",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname AccessSwitch1\ninterface GigabitEthernet0/1\n switchport access vlan 10\n no shutdown"
                },
                {
                    "name": "AccessSwitch2",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname AccessSwitch2\ninterface GigabitEthernet0/1\n switchport access vlan 20\n no shutdown"
                }
            ],
            "links": [
                {"endpoints": ["CoreRouter", "CoreSwitch"], "link_type": "ethernet"},
                {"endpoints": ["CoreSwitch", "AccessSwitch1"], "link_type": "ethernet"},
                {"endpoints": ["CoreSwitch", "AccessSwitch2"], "link_type": "ethernet"}
            ]
        }
    },
    "Full Mesh OSPF Lab (3 Routers)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterA",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterA\ninterface GigabitEthernet0/0\n ip address 10.0.0.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.5 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                },
                {
                    "name": "RouterB",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterB\ninterface GigabitEthernet0/0\n ip address 10.0.0.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.9 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                },
                {
                    "name": "RouterC",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterC\ninterface GigabitEthernet0/0\n ip address 10.0.0.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 10.0.0.10 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.0.0.0 0.0.0.255 area 0"
                }
            ],
            "links": [
                {"endpoints": ["RouterA", "RouterB"], "link_type": "serial"},
                {"endpoints": ["RouterB", "RouterC"], "link_type": "serial"},
                {"endpoints": ["RouterC", "RouterA"], "link_type": "serial"}
            ]
        }
    },
    "Full Mesh EIGRP Lab (3 Routers)": {
        "network_design": {
            "devices": [
                {
                    "name": "RouterX",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterX\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.5 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                },
                {
                    "name": "RouterY",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterY\ninterface GigabitEthernet0/0\n ip address 192.168.1.2 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.9 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                },
                {
                    "name": "RouterZ",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname RouterZ\ninterface GigabitEthernet0/0\n ip address 192.168.1.6 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 192.168.1.10 255.255.255.252\n no shutdown\nrouter eigrp 100\n network 192.168.1.0 0.0.0.255\n no auto-summary"
                }
            ],
            "links": [
                {"endpoints": ["RouterX", "RouterY"], "link_type": "serial"},
                {"endpoints": ["RouterY", "RouterZ"], "link_type": "serial"},
                {"endpoints": ["RouterZ", "RouterX"], "link_type": "serial"}
            ]
        }
    },
    "Multi-Site WAN + LAN Mega-Lab (Multi-Area OSPF + VLANs + PCs)": {
        "network_design": {
            "devices": [
                {
                    "name": "Site1_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Site1_Router\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.10\n encapsulation dot1Q 10\n ip address 10.1.10.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.20\n encapsulation dot1Q 20\n ip address 10.1.20.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.2 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.1.0.0 0.0.255.255 area 1\n network 172.16.1.0 0.0.0.3 area 0\nip route 10.2.0.0 255.255.0.0 172.16.1.1"
                },
                {
                    "name": "Site2_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname Site2_Router\ninterface GigabitEthernet0/0\n no shutdown\ninterface GigabitEthernet0/0.30\n encapsulation dot1Q 30\n ip address 10.2.30.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/0.40\n encapsulation dot1Q 40\n ip address 10.2.40.1 255.255.255.0\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.6 255.255.255.252\n no shutdown\nrouter ospf 1\n network 10.2.0.0 0.0.255.255 area 2\n network 172.16.1.4 0.0.0.3 area 0\nip route 10.1.0.0 255.255.0.0 172.16.1.5"
                },
                {
                    "name": "WAN_Router",
                    "type": "router",
                    "node_definition": "iosv",
                    "config": "hostname WAN_Router\ninterface GigabitEthernet0/0\n ip address 172.16.1.1 255.255.255.252\n no shutdown\ninterface GigabitEthernet0/1\n ip address 172.16.1.5 255.255.255.252\n no shutdown\nrouter ospf 1\n network 172.16.1.0 0.0.0.3 area 0\n network 172.16.1.4 0.0.0.3 area 0\n network 10.1.0.0 0.0.255.255 area 1\n network 10.2.0.0 0.0.255.255 area 2"
                },
                {
                    "name": "Site1_Switch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname Site1_Switch\nvlan 10\nvlan 20\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 10\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 20\n no shutdown"
                },
                {
                    "name": "Site2_Switch",
                    "type": "switch",
                    "node_definition": "iosvl2",
                    "config": "hostname Site2_Switch\nvlan 30\nvlan 40\ninterface GigabitEthernet0/1\n switchport mode trunk\n no shutdown\ninterface GigabitEthernet0/2\n switchport access vlan 30\n no shutdown\ninterface GigabitEthernet0/3\n switchport access vlan 40\n no shutdown"
                },
                {
                    "name": "Site1_PC",
                    "type": "ext-server",
                    "node_definition": "ext-server",
                    "config": "#cloud-config\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: false\n      addresses: [192.168.10.10/24]\n      gateway4: 192.168.10.1\n      nameservers:\n        addresses: [8.8.8.8]"
                },
                {
                    "name": "Site2_PC",
                    "type": "ext-server",
                    "node_definition": "ext-server",
                    "config": "#cloud-config\nnetwork:\n  version: 2\n  ethernets:\n    eth0:\n      dhcp4: false\n      addresses: [192.168.30.10/24]\n      gateway4: 192.168.30.1\n      nameservers:\n        addresses: [8.8.8.8]"
                }
            ],
            "links": [
                {"endpoints": ["Site1_Router", "WAN_Router"], "link_type": "serial"},
                {"endpoints": ["Site2_Router", "WAN_Router"], "link_type": "serial"},
                {"endpoints": ["Site1_Router", "Site1_Switch"], "link_type": "ethernet"},
                {"endpoints": ["Site2_Router", "Site2_Switch"], "link_type": "ethernet"},
                {"endpoints": ["Site1_Switch", "Site1_PC"], "link_type": "ethernet"},
                {"endpoints": ["Site2_Switch", "Site2_PC"], "link_type": "ethernet"}
            ]
        }
    }
}


template_choice = st.sidebar.selectbox("Select a Template", ["Select..."] + list(templates.keys()))

if template_choice != "Select...":
    selected_template = templates[template_choice]

    # VLAN ID customization for Campus LAN (VLANs & Router-on-a-Stick)
    if template_choice == "Campus LAN (VLANs & Router-on-a-Stick)":
        vlan10 = st.sidebar.text_input("Enter VLAN ID for User VLAN", value="10")
        vlan20 = st.sidebar.text_input("Enter VLAN ID for Voice VLAN", value="20")

        if vlan10 and vlan20:
            # Deep copy and replace VLAN IDs dynamically
            selected_template = json.loads(
                json.dumps(selected_template)
                .replace("vlan 10", f"vlan {vlan10}")
                .replace("vlan 20", f"vlan {vlan20}")
                .replace(".10", f".{vlan10}")
                .replace(".20", f".{vlan20}")
            )

    st.session_state['last_mcp_model'] = selected_template

    # --- Begin: Enhanced Device Config Editor ---
    st.subheader("üõ†Ô∏è Customize Device Configurations Before Deployment")

    editable_devices = []

    valid_types = ["router", "switch", "firewall", "server", "ext-server"]
    node_definitions = {
        "router": "iosv",
        "switch": "iosvl2",
        "firewall": "asav",
        "server": "ubuntu",
        "ext-server": "ext-server"
    }

    import re
    for idx, device in enumerate(selected_template["network_design"]["devices"]):
        with st.expander(f"üîß Device {idx+1}: {device.get('name', 'Unnamed')}"):
            name = st.text_input(f"Hostname for Device {idx+1}", value=device.get("name", f"Device{idx+1}"), key=f"name_{idx}")
            dev_type = st.selectbox(
                f"Device Type",
                valid_types,
                index=valid_types.index(device.get("type", "router")),
                help="Hover to see supported interface options per image.",
                key=f"type_{idx}"
            )

            # Add interface info tooltip/caption
            interface_help = {
                "router": "iosv supports Gig0/0 to Gig0/3",
                "switch": "iosvl2 supports Gig0/1 to Gig0/3",
                "firewall": "asav supports up to Gig0/4",
                "server": "ubuntu uses eth0",
                "ext-server": "cloud-init based external VM using eth0"
            }
            st.caption(f"üí° Interface info: {interface_help.get(dev_type, 'Standard interfaces supported.')}")

            # Interface count dropdown per device type
            max_interfaces = 4 if dev_type in ["router", "switch", "firewall"] else 1
            interface_count = st.selectbox("Number of interfaces", list(range(1, max_interfaces + 1)), index=1, key=f"{name}_ifcount")
            interface_configs = []

            for i in range(interface_count):
                # --- Enhanced interface naming suggestion ---
                iface_prefix = "eth" if dev_type in ["server", "ext-server"] else "GigabitEthernet0"
                iface = f"{iface_prefix}/{i}" if "GigabitEthernet" in iface_prefix else f"{iface_prefix}{i}"
                ip = st.text_input(f"IP for {iface}", value=f"192.168.{idx}.{i+1}", key=f"{name}_iface_{i}")
                iface_desc = st.text_input(f"Description for {iface}", value="", key=f"{name}_desc_{i}")
                # For normal interfaces, VLAN is None
                interface_configs.append((iface, ip, None, iface_desc))

                # Allow sub-interfaces for routers (Router-on-a-Stick)
                if dev_type == "router":
                    sub_count = st.number_input(f"How many sub-interfaces on {iface}?", min_value=0, max_value=10, value=0, key=f"{name}_subcount_{i}")
                    for sub_idx in range(1, sub_count + 1):
                        sub_id = st.text_input(f"Sub-interface number (e.g. 1, 10, 20)", value=str(sub_idx * 10), key=f"{name}_subid_{i}_{sub_idx}")
                        # --- Enhanced sub-interface naming ---
                        sub_iface = f"{iface}.{sub_id}"
                        sub_ip = st.text_input(f"IP for {sub_iface}", value=f"192.168.{idx}.{i+sub_idx+1}", key=f"{name}_subiface_{i}_{sub_idx}")
                        vlan_id = st.text_input(f"VLAN ID for {sub_iface}", value=sub_id, key=f"{name}_vlan_{i}_{sub_idx}")
                        sub_desc = st.text_input(f"Description for {sub_iface}", value="", key=f"{name}_desc_sub_{i}_{sub_idx}")
                        interface_configs.append((sub_iface, sub_ip, vlan_id, sub_desc))
                # Allow VLAN ID field for switches (access or trunk)
                elif dev_type == "switch":
                    vlan_id = st.text_input(f"VLAN ID for {iface}", value="", key=f"{name}_vlan_{i}")
                    if vlan_id.strip() != "":
                        interface_configs[-1] = (iface, ip, vlan_id, iface_desc)

            # --- Protocol Toggles and Auto-Detection ---
            raw_config = device.get("config", "")
            enable_ospf = "router ospf" in raw_config
            enable_eigrp = "router eigrp" in raw_config

            ospf_config = {}
            eigrp_config = {}

            if enable_ospf:
                match = re.search(r"router ospf (\d+)", raw_config)
                ospf_process_id = match.group(1) if match else "1"
                area_matches = re.findall(r"area (\d+)", raw_config)
                network_matches = re.findall(r"network (\S+) (\S+) area \d+", raw_config)
                ospf_config = {
                    "process_id": ospf_process_id,
                    "networks": [f"{ip}/{mask.count('255')*8}" for ip, mask in network_matches],
                    "area": area_matches[0] if area_matches else "0"
                }

            if enable_eigrp:
                match = re.search(r"router eigrp (\d+)", raw_config)
                eigrp_as = match.group(1) if match else "100"
                eigrp_nets = re.findall(r"network (\S+)", raw_config)
                eigrp_config = {
                    "as_number": eigrp_as,
                    "networks": eigrp_nets
                }

            # --- BGP auto-detection and parsing ---
            enable_bgp = "router bgp" in raw_config
            bgp_config = {}
            if enable_bgp:
                match = re.search(r"router bgp (\d+)", raw_config)
                bgp_as = match.group(1) if match else "65001"
                neighbor_matches = re.findall(r"neighbor (\S+) remote-as \d+", raw_config)
                network_matches = re.findall(r"network (\S+) mask (\S+)", raw_config)
                bgp_config = {
                    "asn": bgp_as,
                    "neighbors": neighbor_matches,
                    "networks": [f"{ip}/{mask.count('255')*8}" for ip, mask in network_matches]
                }

            enable_ospf = st.checkbox(f"Enable OSPF on {name}?", value=enable_ospf, key=f"ospf_{idx}")
            enable_eigrp = st.checkbox(f"Enable EIGRP on {name}?", value=enable_eigrp, key=f"eigrp_{idx}")
            enable_bgp = st.checkbox(f"Enable BGP on {name}?", value=enable_bgp, key=f"bgp_{idx}")
            enable_static = st.checkbox(f"Add Static Routes to {name}?", key=f"static_{idx}")

            # --- OSPF/EIGRP protocol configuration blocks, prefill from config if present ---
            static_config = []

            if enable_ospf:
                ospf_process_id = st.text_input(
                    f"OSPF Process ID for {name}",
                    value=ospf_config.get("process_id", "1"),
                    key=f"ospf_pid_{idx}"
                )
                ospf_networks = st.text_area(
                    f"OSPF Networks (one per line, CIDR format)",
                    value="\n".join(ospf_config.get("networks", ["10.0.0.0/24"])),
                    key=f"ospf_nets_{idx}"
                )
                ospf_area = st.text_input(
                    f"OSPF Area",
                    value=ospf_config.get("area", "0"),
                    key=f"ospf_area_{idx}"
                )
                ospf_config = {
                    "process_id": ospf_process_id,
                    "networks": ospf_networks.splitlines(),
                    "area": ospf_area
                }

            if enable_eigrp:
                eigrp_as = st.text_input(
                    f"EIGRP Autonomous System Number for {name}",
                    value=eigrp_config.get("as_number", "100"),
                    key=f"eigrp_as_{idx}"
                )
                eigrp_networks = st.text_area(
                    f"EIGRP Networks (one per line, CIDR format)",
                    value="\n".join(eigrp_config.get("networks", ["10.0.0.0/24"])),
                    key=f"eigrp_nets_{idx}"
                )
                eigrp_config = {
                    "as_number": eigrp_as,
                    "networks": eigrp_networks.splitlines()
                }

            # --- BGP and Static config inputs, now prefilled from bgp_config if present ---
            if enable_bgp:
                bgp_asn = st.text_input(
                    f"BGP Autonomous System Number",
                    value=bgp_config.get("asn", "65001"),
                    key=f"bgp_asn_{idx}"
                )
                bgp_neighbors = st.text_area(
                    f"BGP Neighbors (one IP per line)",
                    value="\n".join(bgp_config.get("neighbors", ["192.0.2.2"])),
                    key=f"bgp_neighbors_{idx}"
                )
                bgp_networks = st.text_area(
                    f"BGP Networks to Advertise (one CIDR per line)",
                    value="\n".join(bgp_config.get("networks", ["192.168.0.0/24"])),
                    key=f"bgp_nets_{idx}"
                )
                bgp_config = {
                    "asn": bgp_asn,
                    "neighbors": bgp_neighbors.splitlines(),
                    "networks": bgp_networks.splitlines()
                }

            if enable_static:
                static_entries = st.text_area(f"Static Routes (format: destination subnet mask next-hop IP)", value="10.0.0.0 255.255.255.0 192.168.1.1", key=f"static_entries_{idx}")
                for line in static_entries.strip().splitlines():
                    parts = line.strip().split()
                    if len(parts) == 3:
                        static_config.append(parts)

            updated_device = device.copy()
            updated_device["name"] = name
            updated_device["type"] = dev_type
            updated_device["node_definition"] = node_definitions.get(dev_type, "iosv")

            # --- Dynamic Default Configs ---
            default_configs = {
                "router": "hostname {hostname}\n",
                "switch": "hostname {hostname}\nspanning-tree mode rapid-pvst\n",
                "firewall": "hostname {hostname}\n",
                "server": "#cloud-config\nhostname: {hostname}\n",
                "ext-server": "#cloud-config\nhostname: {hostname}\n"
            }
            base_config = default_configs.get(dev_type, "hostname {hostname}\n")
            config_lines = [base_config.format(hostname=name).strip()]

            for iface, ip, vlan, desc in interface_configs:
                config_lines.append(f"interface {iface}")
                if desc:
                    config_lines.append(f" description {desc}")
                if vlan:
                    config_lines.append(f" encapsulation dot1Q {vlan}")
                config_lines.append(f" ip address {ip} 255.255.255.0")
                config_lines.append(" no shutdown")

            # --- Add protocol configs if toggled ---
            # OSPF
            if ospf_config:
                config_lines.append(f"router ospf {ospf_config['process_id']}")
                for network in ospf_config["networks"]:
                    if "/" in network:
                        ip, mask_length = network.split("/")
                        mask = {
                            "8": "255.0.0.0",
                            "16": "255.255.0.0",
                            "24": "255.255.255.0",
                            "30": "255.255.255.252"
                        }.get(mask_length, "255.255.255.0")
                        config_lines.append(f" network {ip} {mask} area {ospf_config['area']}")

            # EIGRP
            if eigrp_config:
                config_lines.append(f"router eigrp {eigrp_config['as_number']}")
                for network in eigrp_config["networks"]:
                    if "/" in network:
                        ip, _ = network.split("/")
                        config_lines.append(f" network {ip}")
                config_lines.append(" no auto-summary")

            # --- BGP ---
            if bgp_config:
                config_lines.append(f"router bgp {bgp_config['asn']}")
                for neighbor in bgp_config["neighbors"]:
                    config_lines.append(f" neighbor {neighbor} remote-as {bgp_config['asn']}")
                for network in bgp_config["networks"]:
                    if "/" in network:
                        ip, mask_length = network.split("/")
                        mask = {
                            "8": "255.0.0.0",
                            "16": "255.255.0.0",
                            "24": "255.255.255.0",
                            "30": "255.255.255.252"
                        }.get(mask_length, "255.255.255.0")
                        config_lines.append(f" network {ip} mask {mask}")

            # --- Static Routes ---
            for static_entry in static_config:
                dest, mask, next_hop = static_entry
                config_lines.append(f"ip route {dest} {mask} {next_hop}")

            updated_device["config"] = "\n".join(config_lines)
            editable_devices.append(updated_device)

    # Device creation form
    st.markdown("---")
    st.subheader("‚ûï Add New Device")

    with st.form("add_device_form"):
        new_name = st.text_input("New Device Hostname", value="NewDevice")
        new_type = st.selectbox("Device Type", valid_types, index=0)
        new_def = node_definitions.get(new_type, "iosv")
        new_submit = st.form_submit_button("‚ûï Add Device")

    if new_submit:
        new_device = {
            "name": new_name,
            "type": new_type,
            "node_definition": new_def,
            "config": f"hostname {new_name}"
        }
        selected_template["network_design"]["devices"].append(new_device)
        st.success(f"‚úÖ Added device `{new_name}` to the topology. Please edit it above.")
        st.rerun()

    # Overwrite the device configs with edited data
    if st.button("üíæ Apply Edits to Devices"):
        try:
            selected_template["network_design"]["devices"] = editable_devices
            st.success("‚úÖ Updated device configurations applied.")
            draw_network_topology(selected_template)
        except Exception as e:
            st.error(f"‚ùå Failed to update device configurations: {e}")

    # Add a Reset Edits Button
    if st.button("üîÑ Reset Device Edits"):
        st.rerun()
    # --- End: Enhanced Device Config Editor ---

    st.success(f"‚úÖ Template `{template_choice}` loaded into session. You can now deploy it!")
    with st.spinner("Rendering network diagram..."):
        draw_network_topology(selected_template)

# ----------------------
# Save Current Topology as Template (Sidebar)
# ----------------------
st.sidebar.subheader("üìù Save Current Topology as Template")

if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model']:
    template_name = st.sidebar.text_input("Enter a name for the new template:")
    if st.sidebar.button("üíæ Save as Template"):
        if template_name.strip() == "":
            st.sidebar.error("‚ùå Please enter a valid name.")
        else:
            os.makedirs("custom_templates", exist_ok=True)
            save_path = f"custom_templates/{template_name}.json"
            try:
                with open(save_path, "w") as f:
                    json.dump(st.session_state['last_mcp_model'], f, indent=4)
                st.sidebar.success(f"‚úÖ Template `{template_name}` saved successfully!")
            except Exception as e:
                st.sidebar.error(f"‚ùå Failed to save template: {e}")
else:
    st.sidebar.info("‚ÑπÔ∏è No MCP model available to save as template.")

# ----------------------
# Save MCP Model with Nickname
# ----------------------
st.subheader("üíæ Save Current MCP Model with Custom Name")

if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model']:
    custom_name = st.text_input("Enter a custom name for this topology (no spaces, keep it simple):")
    if st.button("üì• Save Topology"):
        if custom_name.strip() == "":
            st.error("‚ùå Please enter a valid name.")
        else:
            os.makedirs("saved_models", exist_ok=True)
            save_path = f"saved_models/{custom_name}.json"
            try:
                with open(save_path, "w") as f:
                    json.dump(st.session_state['last_mcp_model'], f, indent=4)
                st.success(f"‚úÖ Topology saved as `{save_path}`")
            except Exception as e:
                st.error(f"‚ùå Failed to save topology: {e}")
else:
    st.info("‚ÑπÔ∏è No MCP model to save yet.")

# ----------------------
# User Input: Lab Name
# ----------------------
st.session_state['lab_name'] = st.text_input("üñ•Ô∏è Enter Lab ID", st.session_state['lab_name'])

# Display previous chat history
for message in st.session_state['chat_history']:
    with st.chat_message(message["role"]):
        st.markdown(message["text"])

# Get user input
user_input = st.chat_input("Describe your desired network topology...")

if user_input:
    with st.chat_message("user"):
        st.markdown(user_input)

    # Add user input to history
    st.session_state['chat_history'].append({"role": "user", "text": user_input})
    if len(st.session_state['chat_history']) > 10:
        st.session_state['chat_history'] = st.session_state['chat_history'][-10:]

    with st.spinner("Thinking..."):
        try:
            result = graph.invoke({"input": user_input})

            # Auto-retry if the output is not a structured dict
            if result and isinstance(result.get("output"), str):
                st.warning("‚ö†Ô∏è Agent returned text instead of a structured model. Attempting enhanced fallback parsing...")
                user_fallback_prompt = f"""
                You are a network topology extraction agent.

                Extract ONLY the list of devices and links in JSON format, structured exactly like this:

                {{
                  "devices": [
                    {{"name": "RouterA", "type": "router"}},
                    {{"name": "RouterB", "type": "router"}},
                    {{"name": "Switch1", "type": "switch"}}
                  ],
                  "links": [
                    {{"endpoints": ["RouterA", "RouterB"], "link_type": "serial"}},
                    {{"endpoints": ["RouterB", "Switch1"], "link_type": "ethernet"}}
                  ]
                }}

                Now extract based on this input:
                \"\"\"
                {result['output']}
                \"\"\"

                ONLY respond with a valid JSON object matching this format. No explanations, no commentary.
                """
                result = graph.invoke({"input": user_fallback_prompt})

                import re

                # Clean triple backtick formatting if present
                if result and isinstance(result.get("output"), str):
                    cleaned_output = result["output"].strip()
                    if cleaned_output.startswith("```"):
                        cleaned_output = re.sub(r"^```.*?\n", "", cleaned_output, flags=re.DOTALL)
                        cleaned_output = re.sub(r"```$", "", cleaned_output.strip())
                    
                    try:
                        result["output"] = json.loads(cleaned_output)
                        st.success("‚úÖ Cleaned and parsed fallback JSON successfully.")
                    except Exception as e:
                        st.error(f"‚ùå Failed to parse cleaned fallback JSON: {e}")
                        result["output"] = None

            # Ensure MCP model is properly structured with "network_design"
            if result and result.get("output") and "network_design" not in result["output"]:
                result["output"] = {
                    "network_design": result["output"]
                }

            # Enhance the MCP model before saving or deploying
            valid_node_definitions = {"iosv", "iosvl2", "csr1000v", "nxosv", "ubuntu", "server", "ext-server"}

            devices = result["output"].get("network_design", {}).get("devices", [])
            links = result["output"].get("network_design", {}).get("links", [])

            if devices:
                x, y = 100, 100
                x_offset, y_offset = 200, 200
                max_per_row = 3
                count = 0

                role_to_template = {
                    "router": "iosv",
                    "switch": "iosvl2",
                    "firewall": "asav",
                    "server": "ubuntu"
                }

                # --- Begin IP addressing enrichment ---
                base_ip_octets = [10, 0, 0, 0]  # Start at 10.0.0.0
                subnet_step = 4  # /30 blocks
                link_ip_map = {}
                device_interfaces = {device["name"]: [] for device in devices}

                def increment_ip(ip_octets, increment):
                    ip_int = (ip_octets[0] << 24) + (ip_octets[1] << 16) + (ip_octets[2] << 8) + ip_octets[3]
                    ip_int += increment
                    return [(ip_int >> 24) & 0xFF, (ip_int >> 16) & 0xFF, (ip_int >> 8) & 0xFF, ip_int & 0xFF]

                for link in links:
                    endpoints = link.get("endpoints", [])
                    if len(endpoints) == 2:
                        subnet_base = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]}"
                        device_a_ip = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]+1}"
                        device_b_ip = f"{base_ip_octets[0]}.{base_ip_octets[1]}.{base_ip_octets[2]}.{base_ip_octets[3]+2}"
                        link_ip_map[(endpoints[0], endpoints[1])] = (device_a_ip, device_b_ip)

                        # Increment to next /30 block
                        base_ip_octets = increment_ip(base_ip_octets, subnet_step)

                # --- End IP addressing enrichment ---

                for device in devices:
                    device_type = device.get("type", "router").lower()

                    if "node_definition" not in device or device["node_definition"] not in valid_node_definitions:
                        device["node_definition"] = role_to_template.get(device_type, "iosv")

                    if "x" not in device or "y" not in device:
                        device["x"] = x
                        device["y"] = y

                        count += 1
                        if count % max_per_row == 0:
                            x = 100
                            y += y_offset
                        else:
                            x += x_offset

                # Build per-device configs with interface IPs
                for device in devices:
                    config_lines = [f"hostname {device['name']}"]
                    iface_count = 0
                    for link, ips in link_ip_map.items():
                        if device["name"] == link[0]:
                            config_lines.append(f"interface GigabitEthernet0/{iface_count}")
                            config_lines.append(f" ip address {ips[0]} 255.255.255.252")
                            config_lines.append(f" no shutdown")
                            iface_count += 1
                        elif device["name"] == link[1]:
                            config_lines.append(f"interface GigabitEthernet0/{iface_count}")
                            config_lines.append(f" ip address {ips[1]} 255.255.255.252")
                            config_lines.append(f" no shutdown")
                            iface_count += 1
                    device["config"] = "\n".join(config_lines)

            # Save MCP model to session state for later use
            if result and result.get("output"):
                st.session_state['last_mcp_model'] = result["output"]

        except Exception as e:
            st.error(f"‚ùå Graph execution failed: {e}")
            result = None

    if result:
        with st.chat_message("assistant"):
            st.subheader("Agent Output:")
            # Debug console expander for raw output
            with st.expander("üõ†Ô∏è Debug Console (Raw Output)"):
                debug_preview = json.dumps(result, indent=2)
                if len(debug_preview) > 2000:
                    debug_preview = debug_preview[:2000] + "\n...\n‚ö†Ô∏è Output truncated for performance."
                st.code(debug_preview, language="json")
            st.json(result)

        # Add assistant message to history
        st.session_state['chat_history'].append({"role": "assistant", "text": json.dumps(result)})
        if len(st.session_state['chat_history']) > 10:
            st.session_state['chat_history'] = st.session_state['chat_history'][-10:]

        # ----------------------
        # Save MCP Model to JSON file with smarter filename
        # ----------------------
        os.makedirs("saved_models", exist_ok=True)  # Create folder if missing
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        # Attempt smarter filename from device names
        try:
            first_device = result["output"]["network_design"]["devices"][0]["name"]
            clean_name = first_device.replace(" ", "_").lower()
        except Exception:
            clean_name = "mcp_model"
        save_path = f"saved_models/{clean_name}_{timestamp}.json"
        with open(save_path, "w") as f:
            json.dump(result["output"], f, indent=4)
        
        st.success(f"‚úÖ MCP Model saved to `{save_path}`!")
        st.subheader("üåê Visualized Network Topology:")
        with st.spinner("Rendering network diagram..."):
            draw_network_topology(result["output"])

elif user_input:
    st.error("‚ùå Unexpected error. Please try again.")

# ----------------------
# Advanced Controls: Export, Reload, Start/Stop
# ----------------------
st.subheader("‚öôÔ∏è Advanced Controls")

col1, col2, col3 = st.columns(3)

with col1:
    if st.button("üì• Export Network Diagram"):  
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        export_filename = f"saved_models/network_topology_mcp_builder_{timestamp}.html"
        st.success(f"Diagram exported as `{export_filename}`")

with col2:
    saved_files = [f for f in os.listdir("saved_models") if f.endswith(".json")]
    saved_names = [os.path.splitext(f)[0] for f in saved_files]  # Remove .json for display
    selected_file = st.selectbox("üìÇ Reload Saved Topology", ["Select a file..."] + saved_names)

    if selected_file != "Select a file...":
        load_path = f"saved_models/{selected_file}.json"
        with open(load_path, "r") as f:
            loaded_mcp_model = json.load(f)
        st.info(f"‚úÖ Loaded `{selected_file}`")
        with st.spinner("Rendering network diagram..."):
            draw_network_topology(loaded_mcp_model)

        # Allow editing the loaded topology
        st.subheader("üìù Edit Loaded Topology")

        editable_json = st.text_area("Modify the JSON structure below:", json.dumps(loaded_mcp_model, indent=2), height=400)

        # --- Enhanced: Three buttons for Save, Deploy, Save+Deploy ---
        edited_model = None
        col_edit1, col_edit2, col_edit3 = st.columns(3)

        with col_edit1:
            if st.button("üíæ Save Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    save_edit_path = f"saved_models/edited_{selected_file}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.json"
                    with open(save_edit_path, "w") as f:
                        json.dump(edited_model, f, indent=4)
                    st.success(f"‚úÖ Edited topology saved as `{save_edit_path}`")
                except Exception as e:
                    st.error(f"‚ùå Failed to save edited topology: {e}")

        with col_edit2:
            if st.button("üöÄ Deploy Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    from CMLConnector import CMLManager
                    cml_manager = CMLManager()
                    lab_name = f"EditedLab_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    lab = cml_manager.create_lab_from_mcp(edited_model, lab_name)
                    st.success(f"‚úÖ Edited topology deployed! Lab ID: {lab.id}")
                except Exception as e:
                    st.error(f"‚ùå Failed to deploy edited topology: {e}")

        with col_edit3:
            if st.button("üíæ+üöÄ Save and Deploy Edited Topology"):
                try:
                    edited_model = json.loads(editable_json)
                    save_edit_path = f"saved_models/edited_{selected_file}_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.json"
                    with open(save_edit_path, "w") as f:
                        json.dump(edited_model, f, indent=4)
                    from CMLConnector import CMLManager
                    cml_manager = CMLManager()
                    lab_name = f"EditedLab_{datetime.now().strftime('%Y%m%d%H%M%S')}"
                    lab = cml_manager.create_lab_from_mcp(edited_model, lab_name)
                    st.success(f"‚úÖ Edited topology saved and deployed! Lab ID: {lab.id}")
                except Exception as e:
                    st.error(f"‚ùå Failed to save and deploy edited topology: {e}")

with col3:
    st.markdown("üöÄ **Lab Controls**")

    if st.button("üöÄ Deploy New Lab from Model"):
        try:
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()  # Lazy instantiate

            if 'last_mcp_model' in st.session_state and st.session_state['last_mcp_model'] is not None:
                if not st.session_state['lab_name']:
                    st.error("‚ùå Please enter a Lab ID first!")
                    st.stop()

                st.text("üõ† Creating lab...")
                lab = cml_manager.create_lab_from_mcp(st.session_state['last_mcp_model'], st.session_state['lab_name'])
                st.success(f"‚úÖ New Lab Created! Lab ID: {lab.id}")

                st.session_state['last_created_lab_id'] = lab.id
            else:
                st.error("‚ùå No MCP model available to deploy. Please describe a network first.")
        except Exception as e:
            st.error(f"‚ùå Failed to deploy new lab: {e}")

    # Start and Stop buttons (appear only AFTER deploy)
    if 'last_created_lab_id' in st.session_state:
        lab_id = st.session_state['last_created_lab_id']
        if st.button("‚ñ∂Ô∏è Start Lab"):
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()
            st.text("Starting lab...")
            cml_manager.start_lab(lab_id)
            st.success("‚úÖ Lab start requested!")

        if st.button("‚èπ Stop Lab"):
            from CMLConnector import CMLManager  # Lazy import
            cml_manager = CMLManager()
            st.text("Stopping lab...")
            cml_manager.stop_lab(lab_id)
            st.success("‚úÖ Lab stop requested!")

# ----------------------
# Test CML Connection Button
# ----------------------
st.subheader("üß™ Test CML Server Connection")

# Visual connection status indicator
connection_status = st.empty()

if st.button("üîç Test CML Connection"):
    try:
        from CMLConnector import CMLManager
        cml_manager = CMLManager()
        version = cml_manager.client.system_info().get("version", "Unknown")
        connection_status.success(f"üü¢ Connected to CML server (Version: {version})")
    except Exception as e:
        error_message = str(e)
        if "Errno 60" in error_message or "timed out" in error_message.lower():
            connection_status.error("üî¥ Could not connect to CML server: Server unreachable (timed out after 5 seconds).")
        else:
            connection_status.error(f"üî¥ Could not connect to CML server: {error_message}")